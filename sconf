#!/usr/bin/env python3

import argparse
import difflib
import os
import pathlib
import re
import shutil
import subprocess
import sys
import tempfile

import jinja2
import yaml

BASE_PATH = "/etc/sconf/"
MODULES_PATH = os.path.join(BASE_PATH, "modules")


class Color:
    GREEN = '\033[92m'
    RED = '\033[91m'
    BOLD = '\033[1m'
    END = '\033[0m'


class Config:
    def __init__(self):
        for path in [BASE_PATH, MODULES_PATH]:
            if not os.path.exists(path):
                print(
                    "Directory %s%s%s does not exist!" % (
                        Color.BOLD,
                        path,
                        Color.END,
                    )
                )

                sys.exit(1)

    def _get_data(self, file_path, context=None):
        data = None

        if os.path.exists(file_path) and os.path.isfile(file_path):
            with open(file_path, 'r') as content_yaml:
                content = content_yaml.read()

                if context:
                    template = jinja2.Template(content)
                    content = template.render(**context)

                try:
                    data = yaml.load(content, Loader=yaml.BaseLoader)
                except yaml.YAMLError as e:
                    print(e)

        return data

    def module_data(self, module, context=None):
        config_yaml = os.path.join(BASE_PATH, 'modules', module, 'config.yaml')

        config = self._get_data(
            config_yaml,
            context=context,
        )

        return config

    def global_data(self, file_name):
        file_name = '%s.yaml' % file_name
        data_yaml = os.path.join(BASE_PATH, 'global', file_name)
        data = self._get_data(data_yaml)

        return data


class Files:
    def _render_template(self, file_path, context={}):
        tmp = tempfile.NamedTemporaryFile(delete=False)

        with open(file_path) as content_file:
            content = content_file.read()
            template = jinja2.Template(content)
            content = template.render(**context)

        with open(tmp.name, 'w') as tmp_file:
            tmp_file.write(content)

        return tmp_file.name

    def _diff(self, file_path, dest_path):
        output = ''

        try:
            text1 = open(dest_path, 'r').readlines()
            text2 = open(file_path, 'r').readlines()

            for line in difflib.unified_diff(text1, text2):
                if line.startswith('+'):
                    output += '   %s%s%s' % (Color.GREEN, line, Color.END)
                elif line.startswith('-'):
                    output += '   %s%s%s' % (Color.RED, line, Color.END)
                else:
                    output += '   %s' % line
        except UnicodeDecodeError:
            pass

        return output

    def _is_modified(self, file_path, dest_path):
        file_stat = os.stat(file_path)
        dest_stat = os.stat(dest_path)

        return file_stat.st_mtime > dest_stat.st_mtime

    def _get_original_file_path(self, file_path):
        if os.path.islink(file_path):
            return os.readlink(file_path)

        return file_path

    def copy(self, config, module_path, context={}):
        if config is None:
            config = {}

        files_path = os.path.join(module_path, 'files')

        if os.path.isdir(files_path):
            local_variables = config.get('variables', {})

            for file_path in pathlib.Path(files_path).rglob('*'):
                if os.path.isdir(file_path):
                    continue

                file_name, file_extension = os.path.splitext(file_path)
                src_path = os.path.dirname(file_path)

                if file_extension == '.jinja':
                    context = {**context, **local_variables}

                    tmp_path = self._render_template(
                        file_path,
                        context=context,
                    )

                dest_path = os.path.join(
                    src_path.replace(files_path, ''),
                    file_path.name,
                )

                if file_extension == '.jinja':
                    dest_path = dest_path[:-6]

                original_file_path = self._get_original_file_path(file_path)
                diff_output = None
                copy_file = False

                if os.path.exists(dest_path):
                    is_modified = self._is_modified(file_path, dest_path)

                    if is_modified:
                        copy_file = True

                        if file_extension == '.jinja':
                            diff_output = self._diff(
                                tmp_path,
                                dest_path,
                            )
                        else:
                            diff_output = self._diff(
                                original_file_path,
                                dest_path,
                            )

                        if os.path.islink(file_path):
                            print('├─ Update symlink %s' % dest_path)
                        else:
                            print('├─ Update file %s' % dest_path)
                else:
                    copy_file = True

                    if os.path.islink(file_path):
                        print('├─ Create symlink %s' % dest_path)
                    else:
                        print('├─ Create file %s' % dest_path)

                if copy_file is True:
                    if file_extension == '.jinja':
                        shutil.copyfile(tmp_path, dest_path)
                        os.remove(tmp_path)
                    else:
                        if os.path.islink(file_path):
                            linkto = os.readlink(file_path)
                            os.remove(dest_path)
                            os.symlink(linkto, dest_path)
                        else:
                            shutil.copyfile(file_path, dest_path)

                if diff_output:
                    print(diff_output)


class Packages:
    @staticmethod
    def install(config):
        if config is None:
            return

        pkgs = config.get('packages', [])

        for pkg in pkgs:
            cmd = '/usr/bin/dpkg-query -W --showformat=\'${Status}\n\' %s'
            ensure = 'installed'

            if isinstance(pkg, dict):
                pkg_dict = pkg
                pkg = [*pkg_dict][0]
                pkg_options = [*pkg_dict.values()][0]
                ensure = pkg_options.get('ensure', 'installed')

            proc = subprocess.Popen(
                cmd % pkg,
                shell=True,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
            )

            out = str(proc.communicate()[0])
            apt_cmd = None

            if ensure == 'installed':
                if 'install ok installed' in out:
                    print('├─ Package [%s] already installed' % pkg)
                else:
                    apt_cmd = 'install'
                    print('├─ Install package [%s]' % pkg)
            elif ensure == 'purged':
                if 'no packages found' not in out:
                    apt_cmd = 'purge'
                    print('├─ Purge package [%s]' % pkg)

            if apt_cmd:
                subprocess.call(
                    'sudo apt %s -y %s' % (
                        apt_cmd,
                        pkg,
                    ),
                    shell=True,
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.STDOUT,
                )


class Services:
    def __init__(self):
        cmd = 'sudo /bin/systemctl daemon-reload'

        subprocess.call(
            cmd,
            shell=True,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.STDOUT,
        )

    def check(self, config):
        if config is None:
            return

        services = config.get('services', [])

        for service, data in services.items():
            is_active = self.is_active(service)
            is_enabled = self.is_enabled(service)

            enabled = data.get('enabled', None)
            ensure = data.get('ensure', None)

            if enabled is not None:
                if is_enabled is True and enabled == 'false':
                    self.command(service, 'disable')
                    print('├─ Service [%s] disabled' % service)
                elif is_enabled is False and enabled == 'true':
                    self.command(service, 'enable')
                    print('├─ Service [%s] enabled' % service)

            if ensure is not None:
                if is_active is True and ensure == 'stopped':
                    self.command(service, 'stop')
                    print('├─ Service [%s] stopped' % service)
                elif is_active is False and ensure == 'running':
                    print('├─ Service [%s] started' % service)
                    self.command(service, 'start')
                elif ensure == 'running':
                    print('├─ Service [%s] restarted' % service)
                    self.command(service, 'restart')

    def is_active(self, service):
        cmd = '/bin/systemctl status %s' % service

        proc = subprocess.Popen(
            cmd,
            shell=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
        )

        out = str(proc.communicate()[0]).split('\n')

        for line in out:
            search_obj = re.search(
                r'^.*Active:\sactive\s\((running|waiting|exited)\).*$',
                line,
                re.M | re.I,
            )

            if search_obj:
                return True

        return False

    def is_enabled(self, service):
        cmd = '/bin/systemctl status %s' % service

        proc = subprocess.Popen(
            cmd,
            shell=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
        )

        out = str(proc.communicate()[0]).split('\n')

        for line in out:
            search_obj = re.search(
                r'^.*Loaded:\sloaded\s(.*\senabled;\s.*).*$',
                line,
                re.M | re.I,
            )

            if search_obj:
                return True

        return False

    def command(self, service, status):
        cmd = 'sudo /bin/systemctl %s %s' % (status, service)

        subprocess.call(
            cmd,
            shell=True,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.STDOUT,
        )


class ServerConf:
    def __init__(self):
        self.variables = Config().global_data('variables')

    def install_modules(self):
        for module in os.listdir(MODULES_PATH):
            self.install_module(module)

    def install_module(self, module):
        module_path = os.path.join(MODULES_PATH, module)

        if os.path.isdir(module_path):
            print(
                '%sInstall %s module %s' % (
                    Color.BOLD,
                    os.path.basename(module_path),
                    Color.END,
                )
            )

            config = Config().module_data(
                module,
                context=self.variables,
            )

            Packages().install(config)

            Files().copy(
                config,
                module_path,
                context=self.variables,
            )

            Services().check(config)
        else:
            print(
                'Module %s not found!' % (
                    os.path.basename(module_path),
                )
            )


def arguments():
    parser = argparse.ArgumentParser()

    parser.add_argument(
        '-a',
        '--all-modules',
        action='store_true',
        help='Install all module'
    )

    parser.add_argument(
        '-m',
        '--module',
        help='Install module',
    )

    if len(sys.argv) == 1:
        parser.print_help(sys.stderr)
        sys.exit(1)

    args = parser.parse_args()

    server_conf = ServerConf()

    if args.all_modules:
        server_conf.install_modules()
    elif args.module:
        server_conf.install_module(args.module)


arguments()
